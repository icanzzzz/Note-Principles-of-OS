---
title: 内存的连续分配管理方式
---



# Remind

## 内部碎片

- > 分配给某进程的内存区域中，没有用上的部分（相对于分配给目标内存而言，利用不上的部分）

## 外部碎片

- > 内存中的某些空闲分区，由于太小而难以利用（相对于内存而言，分配不出去的内存）

# 单一连续分配

- 只支持单道程序，内存分为系统区和用户区，用户程序放在用户区
- ==无外部碎片，有内部碎片==

# 固定分区分配

- 支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业
- ==无外部碎片，有内部碎片==
- 两种分区方式（都是在操作系统中最开始就确定大小，以后不会改变）
  - 分区大小相等
  - 分区大小不等

# 动态分区分配

- 支持多道程序

- ==无内部碎片，有外部碎片==

- ==紧凑（拼凑，Compaction）==：解决外部碎片问题

  - 换入/换出后==基于动态重定位==继续执行（也就是挪动在内存中的位置，将它们紧紧堆在一起）

- 回收内存分区时，可能遇到四种情况

  - 回收区之后有相邻的空闲分区
  - 回收区之前有相邻的空闲分区
  - 回收区前、后都有相邻的空闲分区
  - 回收区前、后都没有相邻的空闲分区

- 两种常用的数据结构

  - 空闲分区表
  - 空闲分区链

- 动态分区分配算法

  - | 算法         | ==算法思想==                                           | 分区排列顺序                                     | 优点                                                         | 缺点                                                         |
    | ------------ | ------------------------------------------------------ | ------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 首次适应算法 | ==从头到尾找适合的分区==                               | 空闲分区表以地址递增次序排列                     | 综合看性能最好。==算法开销小==，回收分区一般不需要对空闲分区队列重新排序 |                                                              |
    | 最佳适应算法 | ==优先使用更小的分区，以保留更多大分区==               | 空闲分区以容量递增次序排列                       | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片；==算法开销大==，回收分区后可能需要对空闲分区队列重新排序 |
    | 最坏适应算法 | ==优先使用更大的分区，以防止产生太小的不可利用的碎片== | 空闲分区以容量递减次序排列                       | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程；==算法开销大==（原因同上）   |
    | 邻近适应算法 | ==由首次适应演变而来，每次从上次查找结束为止开始查找== | 空闲分区表以地址递增次序排列（可排列成循环链表） | 不用每次都从低地址的小分区开始检索。==算法开销小==（原因同上） | 会使高地址的大分区也被用完                                   |
