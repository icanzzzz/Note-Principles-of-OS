---
title: 进程（Process）
---



# 概念

- > 进程是进程实体==运行的过程==，是系统进行==资源分配==和==调度==的一个独立单位

- 在多道程序环境下，允许多个程序并发执行，此时它们将失去==封闭性==，并具有==间断性==及==不可再现性==的特征

# 特征
## ==动态性==

- > 进程的==最基本特性==

## ==并发性==

- > 内存中有多个进程实体，各进程可并发执行

## ==独立性==

- > 进程是能独立运行、独立获得资源、独立接受调度的基本单位

## ==异步性==

- > 各进程以不可预知的速度向前推进，可能导致运行结果的不确定性

## 结构性

- > 每个进程都会配置一个PCB。结构上看，进程由PCB、程序段、数据段组成

# 组成

## Remind

- ==PCB、程序段、数据段==三部分组成了==进程实体==（==进程映像==）

## 进程控制块（PCB，Process Control Block）

### Remind

- > ==PCB是进程存在的唯一标志==

### 进程描述信息

#### 进程标识符（PID，Process ID）

- > 唯一的、不重复的

#### 用户标识符（UID，User ID）

### 进程控制和管理信息

- 进程当前状态

  - > 就绪态/阻塞态/运行态…

- CPU、磁盘、网络流量使用情况统计…

### 资源分配清单

- 正在使用哪些文件
- 正在使用哪些内存区域
- 正在使用哪些I/O设备

### 处理机相关信息

- 如PSW、PC等等各种寄存器的值

## 程序段

- > 程序的代码（指令序列）

## 数据段

- > 运行过程中产生的各种数据

# 状态

## 三种基本状态

### 运行态（Running）

### 就绪态（Ready）

### 阻塞态（Waiting/Blocked）

## 另外两种状态

### 创建态（New）

### 终止态（Terminated）

## 状态转换

- 运行态->阻塞态：等待系统资源分配，或等待某事件发生（主动行为）
- 阻塞态->就绪态：资源分配到位，等待处理机（被动行为）

# 组织

## 链接方式

1. 按照进程将PCB分为多个队列
2. 操作系统持有指向各个队列的指针

## 索引方式

1. 根据进程状态的不同，建立几张索引表
2. 操作系统持有指向各个索引表的指针

# 控制

## 基本概念

- 进程控制就是要==实现进程状态的转换==
- 进程控制用原语实现
  - 原语用==开/关中断==来实现
  - 原语是一种特殊的程序
  - 原语的执行必须==一气呵成，不可中断==

## 相关原语

### 进程的创建

- 创建原语
  - 申请空白PCB
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列：创建态->就绪态
- 引起进程创建的事件
  - 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程
  - 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
  - 提供服务：用户向操作系统提出的某些请求时，会新建一个进程处理该请求
  - 应用请求：由用户进程主动请求创建一个子进程

### 进程的终止

- 撤销原语
  - 从PCB集合中找到要终止的进程的PCB
  - 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或操作系统
  - 删除PCB
- 引起进程终止的事件
  - 正常结束
  - 异常结束
  - 外界干预

### 进程的阻塞

- 阻塞原语
  - 找到要阻塞的进程的PCB
  - 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
  - 将PCB插入相应事件的等待队列
- 引起进程阻塞的事件
  - 需要等待系统分配某种资源
  - 需要等待相互合作的其他进程完成工作

### 进程的唤醒

- 唤醒原语
  - 在事件等待队列中找到PCB
  - 将PCB从等待队列移除，设置进程为就绪态
  - 将PCB插入就绪队列，等待被调度
- 引起进程唤醒的事件
  - 等待的事件发生

### 进程的切换

- 切换原语
  - 将运行环境信息存入PCB
  - PCB移入相应队列
  - 选择另一个进程执行，并更新其PCB
  - 根据PCB恢复新进程所需要的运行环境
- 引起进程切换的事件
  - 当前进程时间片到
  - 有更高优先级的进程到达
  - 当前进程主动阻塞
  - 当前进程终止

# 通信（IPC）

## 基本概念

- 进程间通信（Inter-Process Communication，IPC）指两个进程之间产生数据交互

## 共享存储

- 设置一个共享内存区域，并映射到进程的虚拟地址空间
- ==互斥==地访问共享空间（由通信进程自己负责实现互斥）
  - 使用操作系统内核提供的同步互斥工具（如P、V操作）
- 两种方式
  - ==基于数据结构（低级）==：比如共享空间里只能放一个长度为10的数组。
  - ==基于存储区的共享（高级）==：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。
- Linux中，实现共享内存
  - Int shm_open(……);//通过shm_open系统调用，申请一片共享内存区
  - Void * mmap(……)//通过mmap系统调用，将共享内存区映射到进程自己的地址空间

## 消息传递

- 传递结构化的消息（消息头/消息体）
- 系统提供“==发送/接受原语==”
- 两种方式
  - 直接通信方式：消息直接==挂到接受进程的消息队列==里
  - 间接（信箱）通信方式：消息先发到==中间体==（信箱）

## 管道通信（文件系统）

- 设置一个==特殊的共享文件==（管道），其实就是一个内存缓冲区
- 一个管道只能实现半双工通信
- 实现双向同时通信要建立两个管道
- 各进程要==互斥访问==管道（由操作系统负责实现互斥）
- 管道写满时，写进程阻塞。管道读空时，读进程阻塞
  - 写进程往管道写数据，即便管道未满，只要管道没空，读进程就可以从管道读数据
  - 读进程从管道读数据，即便管道未空，只要管道没满，写进程就可以往管道写数据